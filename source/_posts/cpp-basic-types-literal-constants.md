title: '基本类型与字面值常量'
tags:
  - Cpp
  - Cpp primer
categories:
  - Dev
  - Cpp
date: 2015-9-10 10:36:09
---

> 版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 4.0](https://creativecommons.org/licenses/by-nc-nd/4.0/)

### 一、基本内置类型 ###
---

C++定义的几种基本的*算术类型*：**int**，**char**，**float**和**bool**。以及特殊的**void**类型，void类型没有对应的值，通常用作无返回值函数的返回类型。

<!-- more -->

|类型	| 含义	| 最小存储空间（位）|
|:---- |:-- -----|:-------------|
|bool	| 布尔型	| - |
|char	| 字符型	| 8|
|wchar_t |	宽字符型	|16|
|short	 | 短整型| 	16|
|int	| 整型	| 16|
|long	| 长整型	| 32|
|float	| 单精度浮点型	| 6位有效数字|
|double | 双精度浮点型	| 10位有效数字|
|long double | 	拓展精度浮点型 |	10位有效数字|

> 注：即使是c++标准规定了存储标准，但是并不能阻止编译器使用更大的存储空间。而且，对于int型几乎所有编译器使用的空间都比所要求的大。

<!-- more -->

#### 整型 ####

表示整数、<span style="color:red">字符</span>和布尔值的算术类型合称为**整型(integral type)**。（*没错，字符也是整型！）* <br/> **1 word(字) = 4 byte(字节) = 32 bit(位)**

- 字符类型有两种：**char**和**wchar_t**。char能够保证存储机器基本字符集中任何字符相应的数值，因此char通常是**单个机器字节**（byte）；**wchar_t**类型用于拓展字符集，如汉字和日语，这些字符集中的一些字符不能用单个char表示；
- **short**、**int**和**long**都表示**整型值**。一般short为半个字（word）长，int为一个字长，而long为一个或两个字长（32位机器中int和long通常字长相同）；
- **bool**：true, false。可以将整型值赋给bool对象，0值表示false，非0值都代表true；

**1.1、signed和unsigned**

整型除了bool之外都可以**带符号**（signed）也可以**不带符号**（unsigned）。

- signed（带符号）：能表示正数也可以表示负数（包括0）；
- unsigned（不带符号）：只能表示0及以上的数；

int，short和long默认是带符号型，需要指定unsigned才能获得无符号类型，其中unsigned int可以简写为unsigned。

**1.2、整型值的表示**

- unsigned类型的所有位均可表示数值。例如，在机器中定义了一种类型使用8位表示，则该类型的取值范围是 0~255；
- signed类型在c++标准中并未定义如何用位来表示（我读的《C++primer》版本是第4版），由编译器自由决定。8位的signed类型取值范围至少是 -127~127，也有允许 -128~127.

**1.3、整型的赋值**

疑问：当把一个超过其取值范围的值赋给一个指定类型的对象时，会发生什么？

- unsigned：编译器必须调整越界值使其满足要求，编译器会将该值对该类型的**可能取值数**求模。<br/>例如8位的unsigned char，取值范围是 0~255，则可能的取值数是 256。当试图把 336存储到unsigned char中，实际存储的是80，因为 336%256 = 80。<br/>
> 注：c++中把负值赋给unsigned对象是完全合法的
- signed：由编译器决定，可能跟unsigned类似，也可能采取其他方式。

#### 浮点型 ####

- float（单精度浮点数）：一个字长（32位）
- double（双精度浮点数）：两个字长（64位）
- long double（拓展精度）：三或四个字长（96位或128位）

### 二、字面值常量 ###
---

像42这样的值，在程序中被称为**字面值常量**（literal constant）。

称它为**字面值**是因为只能用它的值来称呼它，称为**常量**是因为它的值不能被修改。

每个字面值都有相应的类型，例如：0是int型；3.14159是double型。

只有内置类型存在字面值，没有类类型的字面值。因此，标准库类型没有字面值。

#### 整型字面值规则 ####

整数常量可以使用下列三种进制的任意一种：**十进制、八进制和十六进制**。

例如值20的定义：

- decimal:&#9;20
- octal:&#9;024
- hexadecimal:&#9;0x14

字面值整数常量的默认类型为**int或long**。

这取决与字面值——值适合int就是int型，大于int就是long（即，假设int为1机器字长(32位)，则 `-2^31+1 ~ 2^31-1` 为int，大于 `2^31-1` 的为long）。

通过加后缀可以把字面值类型转换成long，unsigned或unsigned long。

- long: 20L
- unsigned: 20U(20u)
- unsigned long: 20UL(20LU/20Lu/20uL)

> 注：定义long类型时，推荐使用大写字母 L ，因为用户读起来时，小写字母 l 很容易和数字 1 混淆！

#### 浮点字面值规则 ####

可以用**十进制或科学计数法**表示浮点字面值常量。

科学计数法指的是，**指数**用 E 或 e 表示。

默认的浮点字面值常量是**double型**。后缀加上 F 或 f 表示单精度，加上 L 或 l 表示拓展精度（<span style="color:red">不推荐使用小写字母 l</span>）

下面每一列的字面值是表示相同的值：

|3.14159F	| .001f |	12.345L	| 0.|
|:--|:--|:--|:--|
|3.14159E0f |	1E-3f  | 1.2345E1L	| 0e0|

### 布尔字面值和字符字面值 ###

bool的字面值： **true和false**。

可打印的字符型字面常量通常用一对单引号来定义： **'a', '2', ',', ' '(空格)**；<br/> 加上 L 可以得到 wchar_t 类型的宽字符字面值： **L'a'**。

#### 非打印字符的转义序列 ####

|\n	|\r	|\a	|\b	|\t	|\v	|\f	|\?	|\"	|\'	|\\|
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|
|换行符|回车符|报警符	|退格符|水平制表符|纵向制表符|进纸符	|疑问号|双引号|单引号	|反斜杠|

任何字符都可以通过 **“\XXX”** 的形式表示，“XXX”表示三位八进制数字。下面是用ASCII码表示字面常量：

- \7 : 报警符
- \0 : 空格符
- \12: 换行符
- \40: 空格符
- \115: 'M'
- \062: '2'

#### 字符串字面值 ####

前面的均是基本内置类型，下面的 **字符串字面值** 会更复杂一些，后续会详细说明。

字符串字面值常量是 **双引号括起来的零个或多个字符**，**不可打印的字符**使用相应的转义字符。

- "Hello World!"
- ""
- "\nHello\tWorld!\n"

> 注：为了兼容C语言，C++会在所有字符串字面值常量末尾添加一个空字符`<br/>`如 'A' 表示 单个字符 A，而 "A" 表示字符 A 和一个空字符两个字符的字符串

#### 字符串字面值的连接 ####

```C++
std::cout << "Hello"
	" "
	"World" "!"
	<< std::endl;
```

等价于

```C++
std::cout << "Hello World!" <<std::endl;
```

但是下面试图连接 **字符串字面值和宽字符串字面值** 是非法的

```C++
std::cout << "Hello" L" World!" <<std::endl;
```

#### 多行字面值 ####

```C++
std::cou\
t<< "Hello" << st\
d::endl;
```

等价于

```C++
std::cout << "Hello" << std::endl;
```

反斜杠 **'\'** 必须是该行的结尾，不允许后面有空格或注释。同样的，下一行的前面也不能有任何空格和制表符。

对于下一个 **长字符串** 例子，反斜杠后也不能有其他字符；而后一行的前面所有空格或制表符都会成为 **长字符串的一部分**。

```C++
std::cout << "Hello \
	World!" << std::endl;
```
END.
